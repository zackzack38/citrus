{{>licenseInfo}}

package {{invokerPackage}}.citrus;

import static org.citrusframework.openapi.generator.TestApiUtils.mapXmlAttributeNameToJavaPropertyName;
import static org.springframework.core.Conventions.attributeNameToPropertyName;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;
import org.citrusframework.actions.SendMessageAction;
import org.citrusframework.config.xml.AbstractSendMessageActionFactoryBean;
import org.citrusframework.http.actions.HttpClientRequestActionBuilder;
import org.citrusframework.http.config.xml.HttpSendRequestActionParser;
import org.citrusframework.http.message.HttpMessage;
import org.citrusframework.http.message.HttpMessageBuilder;
import org.citrusframework.openapi.OpenApiSpecification;
import org.citrusframework.openapi.actions.OpenApiClientRequestActionBuilder.OpenApiClientRequestMessageBuilder;
import org.citrusframework.openapi.actions.OpenApiSpecificationSource;
import org.citrusframework.openapi.generator.TestApiClientRequestActionBuilder;
import org.citrusframework.http.actions.HttpClientRequestActionBuilder.HttpMessageBuilderSupport;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.Assert;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;

{{>additionalModelTypeAnnotations}}{{>generatedAnnotation}}{{#discriminator}}{{>typeInfoAnnotation}}{{/discriminator}}{{>xmlAnnotation}}
public class {{prefix}}BeanDefinitionParser extends HttpSendRequestActionParser {

    private static final String COOKIE = "cookie";
    private static final String HEADER = "header";
    private static final String SOAP_HEADER = "soapHeader";
    private static final String MIME_HEADER = "mimeHeader";
    private static final String NAME = "name";
    private static final String REQUEST_BODY = "body";
    private static final String REQUEST_BODY_LITERAL = "bodyLiteral";
    private static final String MULTIPART_BODY = "multipartBody";
    private static final String RESPONSE = "response";
    private static final String RESPONSE_JSONPATH = "json-path";
    private static final String RESPONSE_XPATH = "xpath";
    private static final String EXPRESSION = "expression";
    private static final String VALUE = "value";
    private static final String RESPONSE_RESOURCE = "resource";
    private static final String FILE = "file";
    private static final String RESPONSE_VARIABLE = "responseVariable";
    private static final String RESPONSE_VALUE = "responseValue";
    private static final String SCRIPT = "script";
    private static final String TYPE = "type";
    private static final String SQL = "sql";
    private static final String COLUMN = "column";
    private static final String VARIABLE = "variable";
    private static final String SCHEMA = "schema";
    private static final String SCHEMA_VALIDATION = "schemaValidation";

    private final Class<? extends TestApiClientRequestActionBuilder> beanClass;

    private final OpenApiSpecification openApiSpecification;

    private String operationId;

    private BeanDefinitionBuilder beanDefinitionBuilder;

    private List<String> constructorParameters;

    private List<String> nonConstructorParameters;

    public {{prefix}}BeanDefinitionParser(OpenApiSpecification openApiSpecification,
        String operationId,
        Class<? extends TestApiClientRequestActionBuilder> beanClass) {
        this.openApiSpecification = openApiSpecification;
        this.operationId = operationId;
        this.beanClass = beanClass;
    }

    public BeanDefinition parse(Element element) {
        return parse(element, null);
    }

    /**
     * Note: The {@link {{prefix}}BeanDefinitionParser#parse(Element element)} allows access direct
     * access without the {@link org.springframework.beans.factory.xml.ParserContext} for convenience.
     */
    @Override
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        super.parse(element, parserContext);

        BeanDefinitionBuilder actionBuilder = BeanDefinitionBuilder.genericBeanDefinition(beanClass);
        actionBuilder.addConstructorArgValue(openApiSpecification);
        for (String parameterName : constructorParameters) {
            actionBuilder.addConstructorArgValue(element.getAttribute(parameterName));
        }

        for (String parameterName : nonConstructorParameters) {
            Attr attribute = element.getAttributeNode(parameterName);
            if (attribute != null) {
                String propertyName = attributeNameToPropertyName(attribute.getLocalName());
                actionBuilder.addPropertyValue(mapXmlAttributeNameToJavaPropertyName(propertyName), attribute.getValue());
            }
        }

        beanDefinitionBuilder.addConstructorArgValue(actionBuilder.getBeanDefinition());
        beanDefinitionBuilder.addPropertyReference("endpoint", "{{apiEndpoint}}");

        /* retrieveRootNodeAttributes(element, beanDefinitionBuilder);
        retrieveOptionalNodeAttributes(element, REQUEST_BODY, beanDefinitionBuilder);
        retrieveTextContentAndNodeAttributes(element, REQUEST_BODY_LITERAL, beanDefinitionBuilder);
        retrieveOptionalNodeAttributes(element, RESPONSE, beanDefinitionBuilder);
        retrieveParamNodeData(element, beanDefinitionBuilder, COOKIE);
        retrieveParamNodeData(element, beanDefinitionBuilder, HEADER);
        retrieveParamNodeData(element, beanDefinitionBuilder, SOAP_HEADER);
        retrieveParamNodeData(element, beanDefinitionBuilder, MIME_HEADER);
        retrieveOptionalNodeAttributes(element, SCHEMA, beanDefinitionBuilder);
        retrieveOptionalNodeAttributes(element, SCHEMA_VALIDATION, beanDefinitionBuilder);
        retrieveOptionalMultipartElements(element, beanDefinitionBuilder);
        retrieveResponseNodeData(element, beanDefinitionBuilder);
        beanDefinitionBuilder.addPropertyValue("name", element.getTagName());
*/
        return beanDefinitionBuilder.getBeanDefinition();
    }

    @Override
    protected BeanDefinitionBuilder parseComponent(Element element, ParserContext parserContext) {
        beanDefinitionBuilder =  BeanDefinitionBuilder.genericBeanDefinition({{prefix}}RequestActionBuilderFactoryBean.class);
        return beanDefinitionBuilder;
    }

    @Override
    protected void validateEndpointConfiguration(Element element) {
        // skip validation, as we support endpoint injection
    }

    @Override
    protected Element getHeadersElement(Element requestElement) {
        Element headers = DomUtils.getChildElementByTagName((Element) requestElement.getParentNode(), "headers");
        return headers;
    }
    @Override
    protected HttpMessageBuilder createMessageBuilder(HttpMessage httpMessage) {
        return new OpenApiClientRequestMessageBuilder(httpMessage,
            new OpenApiSpecificationSource(openApiSpecification), operationId);
    }

    public void setConstructorParameters(String...constructorParameters) {
        this.constructorParameters = constructorParameters != null ? Arrays.asList(constructorParameters) : Collections.emptyList();
    }

    public void setNonConstructorParameters(String...nonConstructorParameters) {
        this.nonConstructorParameters = nonConstructorParameters != null ? Arrays.asList(nonConstructorParameters) : Collections.emptyList();;
    }

    public static class {{prefix}}RequestActionBuilderFactoryBean extends
        AbstractSendMessageActionFactoryBean<SendMessageAction, HttpMessageBuilderSupport, HttpClientRequestActionBuilder> {

        private TestApiClientRequestActionBuilder builder;

        public {{prefix}}RequestActionBuilderFactoryBean(TestApiClientRequestActionBuilder builder) {
            this.builder = builder;
        }

        public void setBuilder(TestApiClientRequestActionBuilder builder) {
            this.builder = builder;
        }

        @Override
        public SendMessageAction getObject() throws Exception {
            return builder.build();
        }

        @Override
        public Class<?> getObjectType() {
            return SendMessageAction.class;
        }

        @Override
        public HttpClientRequestActionBuilder getBuilder() {
            return builder;
        }
    }

   /* private void retrieveOptionalMultipartElements(Element element, BeanDefinitionBuilder builder) {
        var multipartBodyElement = DomUtils.getChildElementByTagName(element, MULTIPART_BODY);
        if (multipartBodyElement != null) {
            var multipartBodyChildElements = DomUtils.getChildElements(multipartBodyElement);
            for(int i = 0; i < multipartBodyChildElements.size(); i++){
                var multipartBodyChildElement = multipartBodyChildElements.get(i);
                String propertyName = Conventions.attributeNameToPropertyName(multipartBodyChildElement.getLocalName());
                builder.addPropertyValue(propertyName, multipartBodyChildElement.getTextContent());
            }
        }
    }

    private void retrieveRootNodeAttributes(Element element, BeanDefinitionBuilder builder) {
        NamedNodeMap attributes = element.getAttributes();
        for (int x = 0; x < attributes.getLength(); x++) {
            Attr attribute = (Attr) attributes.item(x);
            String propertyName = Conventions.attributeNameToPropertyName(attribute.getLocalName());
            Assert.state(StringUtils.isNotBlank(propertyName), "Illegal property name returned, it must not be null or empty.");
            if (!requiredParameterNames.contains(propertyName)) {
                builder.addPropertyValue(TestApiUtils.mapXmlAttributeNameToJavaPropertyName(propertyName), attribute.getValue());
            }
        }
    }

    private void retrieveOptionalNodeAttributes(Element element, String elementName, BeanDefinitionBuilder builder) {
        if (!DomUtils.getChildElementsByTagName(element, elementName).isEmpty()) {
            Element el = DomUtils.getChildElementsByTagName(element, elementName).get(0);
            NamedNodeMap attributes = el.getAttributes();
            for (int x = 0; x < attributes.getLength(); x++) {
                Attr attribute = (Attr) attributes.item(x);
                String propertyName = Conventions.attributeNameToPropertyName(attribute.getLocalName());
                Assert.state(StringUtils.isNotBlank(propertyName), "Illegal property name returned, it must not be null or empty.");
                String variableName = el.getLocalName() + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
                builder.addPropertyValue(variableName, attribute.getValue());
            }
        }
    }

    private void retrieveTextContentAndNodeAttributes(Element element, String elementName, BeanDefinitionBuilder builder) {
        if (!DomUtils.getChildElementsByTagName(element, elementName).isEmpty()) {
            Element el1 = DomUtils.getChildElementsByTagName(element, elementName).get(0);
            NamedNodeMap attributes = el1.getAttributes();
            for (int x = 0; x < attributes.getLength(); x++) {
                Attr attribute = (Attr) attributes.item(x);
                String propertyName1 = Conventions.attributeNameToPropertyName(attribute.getLocalName());
                Assert.state(StringUtils.isNotBlank(propertyName1), "Illegal property name returned, it must not be null or empty.");
                String variableName = el1.getLocalName() + propertyName1.substring(0, 1).toUpperCase() + propertyName1.substring(1);
                builder.addPropertyValue(variableName, attribute.getValue());
            }
            Element el = DomUtils.getChildElementsByTagName(element, elementName).get(0);
            builder.addPropertyValue(elementName, el.getTextContent());
        }
    }

    private void retrieveParamNodeData(Element element, BeanDefinitionBuilder builder, String paramType) {
        if (!DomUtils.getChildElementsByTagName(element, paramType).isEmpty()) {
            Map<String, String> params = new HashMap<>();
            List<Element> elements = DomUtils.getChildElementsByTagName(element, paramType);
            elements.forEach(e -> {
                String name = e.getAttribute(NAME);
                String value = e.getAttribute(VALUE);

                Assert.state(StringUtils.isNotBlank(name), "Illegal attribute value returned. The 'name' attribute must not be null or empty.");
                Assert.state(StringUtils.isNotBlank(value), "Illegal attribute value returned. The 'value' attribute must not be null or empty.");

                params.put(name, value);
            });
            builder.addPropertyValue(paramType, params);
        }
    }

    private void retrieveResponseNodeData(Element element, BeanDefinitionBuilder builder) {

        if (!DomUtils.getChildElementsByTagName(element, RESPONSE).isEmpty()) {
            Element response = DomUtils.getChildElementsByTagName(element, RESPONSE).get(0);
            List<Element> elements = DomUtils.getChildElements(response);

            Map<String, String> responseVariable = new HashMap<>();
            Map<String, String> responseValue = new HashMap<>();

            for (int i = 0; i < elements.size(); i++) {
                Element e = elements.get(i);

                if (e.getTagName().contains(RESPONSE_JSONPATH) || e.getTagName().contains(RESPONSE_XPATH)) {
                    String expression = e.getAttribute(EXPRESSION);
                    String value = e.getAttribute(VALUE);

                    Assert.state(StringUtils.isNotBlank(expression), "Illegal attribute value returned. The 'expression' attribute must not be null or empty.");
                    Assert.state(StringUtils.isNotBlank(value), "Illegal attribute value returned. The 'value' attribute must not be null or empty.");

                    // variable to save @variable('ebid')@ else value to validate
                    if (value.matches("\\@variable\\('.*'\\)\\@")) {
                        Matcher match = Pattern.compile("\\'(.*?)\\'").matcher(value);
                        if (match.find()) {
                            responseVariable.put(expression, value.substring(match.start() + 1, match.end() - 1));
                        }
                    } else {
                        responseValue.put(expression, value);
                    }
                } else if (e.getTagName().contains(SCRIPT)) {
                    String script = e.getTextContent();
                    Assert.state(StringUtils.isNotBlank(script), "Illegal attribute value returned. The 'script' attribute must not be null or empty.");
                    builder.addPropertyValue(SCRIPT, script);

                    if (!e.getAttribute(TYPE).isEmpty()) {
                        String type = e.getAttribute(TYPE);
                        Assert.state(StringUtils.isNotBlank(type), "Illegal attribute value returned. The 'type' attribute must not be null or empty.");
                        builder.addPropertyValue(TYPE, type);
                    }
                } else if (e.getTagName().contains(RESPONSE_RESOURCE)) {
                    String filePath = e.getAttribute(FILE);
                    Assert.state(StringUtils.isNotBlank(filePath), "Illegal attribute value returned. The 'file' attribute must not be null or empty.");
                    builder.addPropertyValue(RESPONSE_RESOURCE, filePath);
                }

            }

            builder.addPropertyValue(RESPONSE_VARIABLE, responseVariable);
            builder.addPropertyValue(RESPONSE_VALUE, responseValue);
        }
    }*/
}
